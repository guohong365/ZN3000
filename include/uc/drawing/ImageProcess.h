//////////////////////////////////////////////////////////////////////////////////
// CimageProcess.h
// Author : BAla
//////////////////////////////////////////////////////////////////////////////////
#pragma once
#include <GdiPlus.h>
namespace uc
{
    namespace drawing{

        // Image Processing class
        class LIB_UC_API CImageProcessor
        {
        public:
            static double m_3DCorrectRatio;

            // Constructor
            CImageProcessor();
            // Destructor
            ~CImageProcessor();

            // Image processing
            ///////////////////////////////////////////////////////////////////////////////
            ///  public static  Blur
            ///  模糊图像
            ///
            ///  @param [in, out]  pImage Gdiplus::Bitmap *    直接修改当前图像
            ///
            ///  This function doesn't return a value
            ///
            ///  @remarks 因该函数直接修改源图像，如果希望保留原始图像的，应调用前做好备份
            ///
            ///  @see Sharpness InvertColor BlackAndWhite Contrast Brightness
            ///
            ///  @author 郭鸿 @date 2008-11-18
            ///////////////////////////////////////////////////////////////////////////////
            /////// comment generated by CommentMakerPro from www.FeinSoftware.com ////////
            static void Blur(Gdiplus::Bitmap *pImage);
            ///////////////////////////////////////////////////////////////////////////////
            ///  public static  Sharpness
            ///  锐化图像
            ///
            ///  @param [in, out]  pImage Gdiplus::Bitmap *    直接修改当前图像
            ///
            ///  This function doesn't return a value
            ///
            ///  @remarks 因该函数直接修改源图像，如果希望保留原始图像的，应调用前做好备份
            ///
            ///  @see Blur
            ///
            ///  @author 郭鸿 @date 2008-11-18
            ///////////////////////////////////////////////////////////////////////////////
            /////// comment generated by CommentMakerPro from www.FeinSoftware.com ////////
            static void Sharpness(Gdiplus::Bitmap *pImage);
            static void InvertColor(Gdiplus::Bitmap *pImage);
            static void BlackAndWhite(Gdiplus::Bitmap *pImage);
            static void Contrast(Gdiplus::Bitmap *pImage, int nContrastVal);	
            static void Brightness(Gdiplus::Bitmap *pImage, int nRedVal, int nGreenVal, int nBlueVal);

            ///////////////////////////////////////////////////////////////////////////////
            ///  public static  CorrectImage
            ///  使用正方形标尺对照片图像进行梯形校正
            ///
            ///  @param [in]       pBitmap Gdiplus::Bitmap *    原始照片
            ///  @param [in]       pt0 const Gdiplus::Point *    正方形标尺在照片中的坐标
            ///  @param [in]       ratio double   矩形长宽比
            ///  @param [in, out]  param void * [=0]    回调函数参数
            ///  @param [in]       callback bool (*)(void *, long, long) [=0]    回调函数指针
            ///
            ///  @return Gdiplus::Bitmap * 校正后的图像
            ///
            ///  @remarks 本方法只适用于正方形标尺。即传入的四个点坐标应代表现实中的正方形四个顶点，否则计算结果不确定，或造成
            ///           程序崩溃。回调函数非空时，计算循环中会调用该函数用以和UI交互（例如显示进度条）。call_back(void *param, long id, long value),
            ///           param将调用时的param参数回传进回调函数，id=0时，value为总执行步数；id=1时value为当前步数                 
            ///
            ///  @author 郭鸿 @date 2008-11-18
            ///////////////////////////////////////////////////////////////////////////////
            /////// comment generated by CommentMakerPro from www.FeinSoftware.com ////////
            static Gdiplus::Bitmap *CorrectImage( Gdiplus::Bitmap * pBitmap, const Gdiplus::Point *pt0, double radio, void *param=NULL,  bool (*callback)(void *, long , long )=NULL);
            static Gdiplus::Bitmap *ExpandTyreFrontImage( Gdiplus::Bitmap * pBitmap, const Gdiplus::Point *pt0, int area_height, void *param=NULL,  bool (*callback)(void *, long , long )=NULL);
            static Gdiplus::Bitmap *ExpandTyreSideImage(  Gdiplus::Bitmap * pBitmap, const Gdiplus::Point *pt0, int inner, void *param=NULL,  bool (*callback)(void *, long , long )=NULL);
            static Gdiplus::Bitmap *ImageCut( Gdiplus::Bitmap * pBitmap, const Gdiplus::Point *pt0,int ptCount, void *param, bool (*callback)( void * , long , long));
            static Gdiplus::Bitmap *ImageCut( Gdiplus::Bitmap * pBitmap, const Gdiplus::GraphicsPath *pCutRegion);
        private:
            // For GDI plus
            Gdiplus::GdiplusStartupInput m_gdiplusStartupInput;
            ULONG_PTR	m_gdiplusToken;
        };
    }
}